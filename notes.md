# FastAPI calculator
- К решению задачи калькулятора можно подойти двумя способами - алгоритмом рекурсивного спуска или алгоритмом сортировочной станции с последующим парсингом постфиксной формы. Я решил задачу первым способом, для второго успел набросать не полностью рабочее решение (файл _shunting_yard_algorithm.py).
- Приоритет операций учитывается, скобки поддерживаются.
- Также в задании обнаружена ошибка: 5 + - 4 должно быть равно 1.

## Алгоритм рекурсивного спуска
Задача разбивается на следующие проблемы:
1. Выделить из входящего потока лексем токены.
    - Лексема - это последовательность символов, образующая токен (например, символы '1', '.', '2' образуют токен '1.2').
    - Токен - это структура, имеющая тип и значение (например, токен '1.2' имеет тип 'n' - number и значение 1.2, токен '+' означает сам себя и имеет тип '+').
2. Разобрать токены и вычислить выражение в соответствии с определенной грамматикой.
    - Для вычисления выражения необходимо определить правила грамматики этого выражения (https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form).

### Выделение токенов из потока лексем
- Функция lexer отвечает за преобразование исходного выражения в токены.
- Вспомогательная структура - тип Token с атрибутами kind: str, value: str. Идентифицирует отдельный токен.

Алгоритм работы:
1. Принимает строку и преобразует ее в очередь (поскольку по алгоритму необходимо извлекать и возвращать символы в структуру, которую читаем последовательно).
2. Читая очередь, получаем символ.
3. Определяем тип символа (цифра, десятичный разделитель, оператор, скобки, пустая строка).
4. Если это цифра, то возможны 3 сценария:
    - это число, состоящее из 1 или более цифр;
        - в этом случае читаем следующий символ, если он является цифрой, читаем в цикле до конца выражения, помещая цифры в список nums.
    - это дробное число, состоящее из цифры, десятичного разделителя и 1 или более цифр.
        - в этом случае читаем следующий символ. Если это десятичный разделитель, читаем следующий символ. Если очередь пуста, выходим из основного цикла. Читаем следующий символ, подразумевающий дробную часть числа. Если символ - не цифра, то лексема вида "2." преобразуется в токен "2.0" Иначе: до тех пор, пока символ - цифра, читаем символ.
    - Сформировав число, создаем токен, указывая его тип (атрибут kind). Для чисел тип токена - n (number) и значение (число). Добавляем к списку токенов.
5. Если символ - это оператор или скобки:
    - Создаем токен, указывая символ в качестве типа (kind) токена. Для токенов, не являющихся числом, value по умолчанию 0 (типа kind для описания токена этого вида достаточно).
6. Если символ - это пустая строка, игнорируем символ.
7. Если символ - не цифра, десятичный разделитель, оператор, скобки, пустая строка, поднимаем ValueError.
8. Возвращаем очередь токенов.

### Разбор токенов и вычисление выражения
Для калькулятора, поддерживающего стаднартный набор операций, отрицательные числа, скобки и порядок вычислений, грамматика будет иметь следующий вид:
```
expr: term | expr "+" term | expr "-" term
term: factor | term "*" factor | term "/" factor
factor: NUM | "-" NUM | "(" expr ")"
```
Например, `expr` - это выражение, состоящее из `term` ИЛИ `expr + term` ИЛИ `expr - term`.

- Класс Parser - определяет парсер, разбирающий токены и на ходу вычисляющий результат выражения.
- Класс TokenStream - управляет потоком токенов типа Token. Имеет методы peek (просматривает токен без его извлечения) и next (извлекает токен, если есть, иначе - raise IndexError).

**Алгоритм работы**
- Парсер читает грамматику, спускаясь с expr на нижний уровень продукции (левая часть выражения) до тех пор, пока не определит ее тип (т.е. expr -> term -> factor). Иначе, если тип не определен на уровне factor, токен ищется на уровне term, иначе - на уровне expr.
- Пример: 1 + 2. Читая последовательно:
    - expr - это term, который factor, который является NUM (число).
    - За операндом всегда следует оператор, поэтому на уровне term получаем следующий токен и сохраняем его в переменную op. Определяем ее тип на уровне term. '+' != '*' и '+' != '/', поэтому возвращаем токен на уровень expr.
    - Проверяем тип текущего токена на соответствие '+' или '-' **не извлекая его**. Если соответствует, извлекаем токен и суммируем левую часть выражения (1) с результатом вызова term (term аналогично является factor, который является NUM = 2).
    - Возвращаем левую часть выражения, которая является результатом вычисления.

## To do
- [ ] Закончить реализацию алгоритмом сортировочной станции (файл _shunting_yard_algorithm.py).
- [ ] Проверка регулярным выражением входящей строки, чтобы не обрабатывать заведомо неверные результаты.
- [ ] Дописать поддержку выражения вида "2. / 1.".
- [ ] Добавить операцию возведения в степень: ^.
